// Code generated by sqlc. DO NOT EDIT.
// source: tags.sql

package db

import (
	"context"
	"time"

	"github.com/gofrs/uuid"
	"github.com/lib/pq"
)

const tagCreate = `-- name: TagCreate :one
insert into tags (user_id, name) values ($1, $2) returning id, user_id, name, created_at, updated_at
`

type TagCreateParams struct {
	UserID uuid.UUID
	Name   string
}

func (q *Queries) TagCreate(ctx context.Context, arg TagCreateParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, tagCreate, arg.UserID, arg.Name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tagDelete = `-- name: TagDelete :one
delete from tags where user_id = $1 and id = $2 returning id, user_id, name, created_at, updated_at
`

type TagDeleteParams struct {
	UserID uuid.UUID
	ID     uuid.UUID
}

func (q *Queries) TagDelete(ctx context.Context, arg TagDeleteParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, tagDelete, arg.UserID, arg.ID)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tagFind = `-- name: TagFind :one
select id, user_id, name, created_at, updated_at from tags where user_id = $1 and id = $2
`

type TagFindParams struct {
	UserID uuid.UUID
	ID     uuid.UUID
}

func (q *Queries) TagFind(ctx context.Context, arg TagFindParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, tagFind, arg.UserID, arg.ID)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tagFindAll = `-- name: TagFindAll :many
select id, user_id, name, created_at, updated_at from tags where user_id = $1 and id = ANY($2::uuid[])
`

type TagFindAllParams struct {
	UserID uuid.UUID
	Ids    []uuid.UUID
}

func (q *Queries) TagFindAll(ctx context.Context, arg TagFindAllParams) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, tagFindAll, arg.UserID, pq.Array(arg.Ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagList = `-- name: TagList :many
select id, user_id, name, created_at, updated_at from tags where user_id = $1
`

func (q *Queries) TagList(ctx context.Context, userID uuid.UUID) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, tagList, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagMove = `-- name: TagMove :one
update tags set name = $3 where user_id = $1 and id = $2 returning id, user_id, name, created_at, updated_at
`

type TagMoveParams struct {
	UserID uuid.UUID
	ID     uuid.UUID
	Name   string
}

func (q *Queries) TagMove(ctx context.Context, arg TagMoveParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, tagMove, arg.UserID, arg.ID, arg.Name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tagsDrop = `-- name: TagsDrop :many
select tags.id, tags.user_id, tags.name, tags.created_at, tags.updated_at from tags
join drop_tags on drop_tags.tag_id = tags.id
join drops on drops.id = drop_tags.drop_id
where drops.user_id = $1 and drops.id = $2
`

type TagsDropParams struct {
	UserID uuid.UUID
	ID     uuid.UUID
}

func (q *Queries) TagsDrop(ctx context.Context, arg TagsDropParams) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, tagsDrop, arg.UserID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagsDrops = `-- name: TagsDrops :many
select tags.id, tags.user_id, tags.name, tags.created_at, tags.updated_at, drops.id as drop_id from tags
join drop_tags on drop_tags.tag_id = tags.id
join drops on drops.id = drop_tags.drop_id
where drops.user_id = $1 and drops.id = ANY($2::uuid[])
`

type TagsDropsParams struct {
	UserID  uuid.UUID
	DropIds []uuid.UUID
}

type TagsDropsRow struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Name      string
	CreatedAt time.Time
	UpdatedAt time.Time
	DropID    uuid.UUID
}

func (q *Queries) TagsDrops(ctx context.Context, arg TagsDropsParams) ([]TagsDropsRow, error) {
	rows, err := q.db.QueryContext(ctx, tagsDrops, arg.UserID, pq.Array(arg.DropIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TagsDropsRow
	for rows.Next() {
		var i TagsDropsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DropID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
